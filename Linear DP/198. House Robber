class Solution {
    public int call(int[] nums, int idx, int n, int[] dp){
        if(idx >= n){
            return 0;
        }
        if(dp[idx] != -1){
            return dp[idx];
        }
        int pick = nums[idx] + call(nums, idx + 2, n, dp);
        int npick = call(nums, idx + 1, n, dp);
        return dp[idx] = Math.max(pick, npick);
    }
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        int[] dp = new int[3];
        //Arrays.fill(dp,-1);  
        //return call(nums, 0, n, dp);
        dp[(n - 1) % 3] = nums[n - 1];
        if(n - 2 >= 0){
            dp[(n - 2) % 3] = Math.max(nums[n - 2], nums[n - 1]);
        }
        for(int i = n - 3; i >= 0; i--){
            int pick = nums[i] + dp[(i + 2) % 3];
            int npick = dp[(i + 1) % 3];
            dp[i % 3] = Math.max(pick, npick);
        }
        return Math.max(dp[0], dp[1]);
    }
}
//Optimal solution
//Time complexity: O(n)
//Space Complexity: O(n)
